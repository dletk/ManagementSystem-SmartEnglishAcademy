package Model;

import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;

/**
 * The model manager class to control all the logic of working with models and database
 * in the program.
 */
public class ModelManager {
    private DatabaseManager databaseManager;
    private ArrayList<User> users;
    private HashMap<String, ArrayList<Shift>> shifts;

    public ModelManager() {
        this.databaseManager = new DatabaseManager();
        this.users = databaseManager.getUsers();
        this.shifts = databaseManager.getShifts();
    }

    public ArrayList<User> getUsers() {
        return this.users;
    }

    public HashMap<String, ArrayList<Shift>> getShifts() {
        return this.shifts;
    }

    /**
     * Method to update the data of a user
     *
     * @param user          the user to update the data
     * @param fieldsAndData the data to update in the database
     * @return true if data is updated
     */
    public boolean updateUser(User user, HashMap<String, String> fieldsAndData) {
        String userID = Integer.toString(user.getUserID());

//        Get users and shifts from the new query after updating
        if (databaseManager.updateUser(userID, fieldsAndData)) {
            users = databaseManager.getUsers();
            shifts = databaseManager.getShifts();
        }
        return true;
    }

    /**
     * The method to add a user to the database thorough the Model manager
     *
     * @param username
     * @param phone
     * @param firstname
     * @param lastname
     * @param email
     * @param role
     * @param password
     * @return true if the user is added successfully
     */
    public boolean addUser(String username, long phone, String firstname, String lastname, String email, String role, String password) {
//        TODO: User id is generated by the length of total users in database + 1, this is not safe if some users get deleted
        int userID = users.size() + 1;

        // Lowercase username so it will not be case-sensitive and strictly unique
        boolean success = databaseManager.addUser(userID, phone, username.toLowerCase(), firstname, lastname, email, role, password);

        if (success) {
//        After added user, get the users list and the shifts from database again
            users = databaseManager.getUsers();
            shifts = databaseManager.getShifts();
            return true;
        } else {
            return false;
        }
    }

    /**
     * Method to check whether the entered password and username is valid from database
     *
     * @param username the username to log in
     * @param password the input password for give username
     * @return true if password is matched to username
     */
    public boolean isValidPassword(String username, String password) {
        for (User user : users) {
            if (user.getUsername().equals(username) && user.getPassword().equals(password)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Method to check whether the entered password and username is a valid admin
     *
     * @param username the admin username
     * @param password password
     * @return true if the given username and password is from an admin
     */
    public boolean isValidAdmin(String username, String password) {
        for (User user : users) {
            if (user.getRole().equals("admin") && user.getUsername().equals(username) && user.getPassword().equals(password)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Method to get a user from database by username
     *
     * @param username the username to retrieve
     * @return User if username is in database, null otherwise
     */
    public User getUser(String username) {
        for (User user: users) {
            if (user.getUsername().equals(username)) {
                return user;
            }
        }
        return null;
    }

    /**
     * Method to begin the clock in process for this user
     *
     * @param user
     * @return true if the clock in process is done successfully
     */
    public boolean clockIn(User user) {
//        Check if user is currently clocked in
        if (isUserClockedIn(user)) {
//            User is currently clocking in, last shift is not clocked out
            System.out.println("====> NOT ABLE TO CLOCK IN");
            return false;
        } else {
            //            The last shift is clocked out. Good to clock in.
            addShift(user.getUserID());
            System.out.println("====> CLOCKED IN");

            return true;
        }
    }


    /**
     * Method to clock out a shift
     *
     * @param user the user with the shift to be clocked out
     * @return true if the shift is clocked out successfully
     */
    public boolean clockOut(User user) {
        // Get the most recent shift of this user
        Shift lastShift = getLastShift(user);

        // Check if whether user is currently clocked in
        if (isUserClockedIn(user)) {
            // Good to clock out
            addEndingTime(lastShift);
            return true;
        } else {
            // The last shift has been clocked out, should be clocked in now
            System.out.println("NOT ABLE TO CLOCK OUT");
            return false;
        }
    }

    /**
     * Method to add a new shift for a user after checking for validation
     *
     * @param userID the id of the user
     */
    private void addShift(int userID) {
        databaseManager.addShift(userID);

//        Update the shifts list from database again
        shifts = databaseManager.getShifts();
    }

    private boolean addEndingTime(Shift shift) {
        long currentTime = System.currentTimeMillis();

        // The time to put in as input for database should be in seconds
        boolean result = databaseManager.updateShift(shift, "endingTime", Long.toString(currentTime / 1000));

        long lengthInSeconds = calculateTimeDifference(shift.getDate() + " " + shift.getStartingTime(), new Date(currentTime));

        double length = ((double) lengthInSeconds) / 3600.0;
        DecimalFormat formatLength = new DecimalFormat("0.##");

        databaseManager.updateShift(shift, "length", formatLength.format(length));

        if (result) {
            // Update the shifts list from database
            shifts = databaseManager.getShifts();
            return true;
        } else {
            return false;
        }
    }

    /**
     * A small helper method to calculate the time difference in seconds between 2 time
     *
     * @param startingTime the starting time in the format of YYYY:MM:dd HH:mm:ss
     * @param endingTime   the ending time in this case is a Date object
     * @return number of seconds different between 2 time records
     */
    private long calculateTimeDifference(String startingTime, Date endingTime) {
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

        try {
            Date start = formatter.parse(startingTime);
            return (endingTime.getTime() - start.getTime()) / 1000;
        } catch (Exception e) {
            System.out.println("Cannot parse date value");
            e.printStackTrace();
            return 0;
        }
    }


    /**
     * Method to check whether the given user is clocked in.
     *
     * @param user The input user to check for status
     * @return true if the input user is clocked in. false otherwise.
     */
    public boolean isUserClockedIn(User user) {
        // Get the last shift if this user
        Shift userLastShift = getLastShift(user);

        if (userLastShift == null) {
            return false;
        } else {
            /* Check whether the last shift has ending time. If it does NOT, then this user is currently clocked in */
            return userLastShift.getEndingTime().isEmpty();
        }
    }

    /**
     * Method to return the last shift of the given user
     * @param user
     * @return the last shift, or NULL if the current user does not have a shift list (new user)
     */
    public Shift getLastShift(User user) {
        // Get al the user shifts
        ArrayList<Shift> userShifts = shifts.get(user.getUsername());

        if (userShifts != null) {
            return userShifts.get(0);
        } else {
            return null;
        }
    }

    /**
     * Method to check whether the given username is available to use
     *
     * @param username the username intended to use
     * @return true if this username is not taken
     */
    public boolean isAvailableUsername(String username) {
        // Loop through all current username to check
        for (User user: users) {
            // lowercase the username to make sure it is not case-sensitive
            if (user.getUsername().equals(username.toLowerCase())) {
                return false;
            }
        }
        return true;
    }
}
